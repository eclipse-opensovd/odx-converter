// automatically generated by the FlatBuffers compiler, do not modify

package dataformat

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
class EcuData : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : EcuData {
        __init(_i, _bb)
        return this
    }
    val version : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val versionAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun versionInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    val ecuName : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ecuNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun ecuNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    val revision : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val revisionAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun revisionInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    fun metadata(j: Int) : dataformat.KeyValue? = metadata(dataformat.KeyValue(), j)
    fun metadata(obj: dataformat.KeyValue, j: Int) : dataformat.KeyValue? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val metadataLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    fun featureFlags(j: Int) : Byte {
        val o = __offset(12)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1)
        } else {
            0
        }
    }
    val featureFlagsLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    val featureFlagsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun featureFlagsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    fun variants(j: Int) : dataformat.Variant? = variants(dataformat.Variant(), j)
    fun variants(obj: dataformat.Variant, j: Int) : dataformat.Variant? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val variantsLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    fun functionalGroups(j: Int) : dataformat.FunctionalGroup? = functionalGroups(dataformat.FunctionalGroup(), j)
    fun functionalGroups(obj: dataformat.FunctionalGroup, j: Int) : dataformat.FunctionalGroup? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val functionalGroupsLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    fun dtcs(j: Int) : dataformat.DTC? = dtcs(dataformat.DTC(), j)
    fun dtcs(obj: dataformat.DTC, j: Int) : dataformat.DTC? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val dtcsLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_9_23()
        fun getRootAsEcuData(_bb: ByteBuffer): EcuData = getRootAsEcuData(_bb, EcuData())
        fun getRootAsEcuData(_bb: ByteBuffer, obj: EcuData): EcuData {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createEcuData(builder: FlatBufferBuilder, versionOffset: Int, ecuNameOffset: Int, revisionOffset: Int, metadataOffset: Int, featureFlagsOffset: Int, variantsOffset: Int, functionalGroupsOffset: Int, dtcsOffset: Int) : Int {
            builder.startTable(8)
            addDtcs(builder, dtcsOffset)
            addFunctionalGroups(builder, functionalGroupsOffset)
            addVariants(builder, variantsOffset)
            addFeatureFlags(builder, featureFlagsOffset)
            addMetadata(builder, metadataOffset)
            addRevision(builder, revisionOffset)
            addEcuName(builder, ecuNameOffset)
            addVersion(builder, versionOffset)
            return endEcuData(builder)
        }
        fun startEcuData(builder: FlatBufferBuilder) = builder.startTable(8)
        fun addVersion(builder: FlatBufferBuilder, version: Int) = builder.addOffset(0, version, 0)
        fun addEcuName(builder: FlatBufferBuilder, ecuName: Int) = builder.addOffset(1, ecuName, 0)
        fun addRevision(builder: FlatBufferBuilder, revision: Int) = builder.addOffset(2, revision, 0)
        fun addMetadata(builder: FlatBufferBuilder, metadata: Int) = builder.addOffset(3, metadata, 0)
        fun createMetadataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMetadataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addFeatureFlags(builder: FlatBufferBuilder, featureFlags: Int) = builder.addOffset(4, featureFlags, 0)
        fun createFeatureFlagsVector(builder: FlatBufferBuilder, data: ByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i])
            }
            return builder.endVector()
        }
        fun startFeatureFlagsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addVariants(builder: FlatBufferBuilder, variants: Int) = builder.addOffset(5, variants, 0)
        fun createVariantsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startVariantsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addFunctionalGroups(builder: FlatBufferBuilder, functionalGroups: Int) = builder.addOffset(6, functionalGroups, 0)
        fun createFunctionalGroupsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startFunctionalGroupsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDtcs(builder: FlatBufferBuilder, dtcs: Int) = builder.addOffset(7, dtcs, 0)
        fun createDtcsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDtcsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endEcuData(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishEcuDataBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset)
        fun finishSizePrefixedEcuDataBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset)
    }
}
